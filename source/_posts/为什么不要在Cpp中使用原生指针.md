---
title: 为什么不要在 C++ 中使用原生指针
date: 2016-03-17 10:27:07
tags:
  - 编程
---

我在这里不想讨论产能问题，只想说一个事情，原生指针是非异常安全的。

比如下面这段：


```
MyClass *p = new MyClass();

// ...

delete p;
```

<!--more-->

很显然，如果中间的代码抛出了任何一个异常，控制流就不继续向下执行，p所指向的内存也不会被回收。相比起这个，原生指针侵入式修改对象看起来也没什么。因为这是我们可控制的，不作死就不会死；但是如果中间的代码里面调用了别人的库，异常由别人的库产生，则是我们控制不了的。

同理，C语言标准库中的一些需要关闭的函数，比如I/O，到了C++中也变得不安全。这也是避免使用C标准库的原因之一。

解决方案是使用try-finally（c#中使用using语法糖），但是c++里面没有finally，可以使用try-catch-rethrow来达到相同的效果：


```
MyClass *p = new MyClass();
try 
{
    // ...
}
catch(exception &ex)
{
    delete p;
    throw ex;
}
```

但是这样写不麻烦吗？与之相比，标准库里面的智能指针可是简洁的多。

```
auto p = make_unique<MyClass>();

//...
```

智能指针相当于一个RAII的包装器，它能保证析构器在对象离开作用域时一定会调用，从而回收资源。智能指针默认的回收行为是delete，如果需要使用特别的函数来回收，可以自定义回收器。

至于一些“原”教旨主义者。你们用不好智能指针，就能用得好原生指针了？
